![Deploice logo](https://github.com/chriskiehl/Deoplice/raw/master/images/logo-cropped.jpg)


"to a great depth"

Deoplice is a library focused on making updates to deeply nested immutable objects pleasant. It's intended to be symbiotic with Lombok. It pick up where `With` and `@Builder` leave off. 



Deoplice picks up where Lombok's `With` and `Builder` leave off: dealing with updates to deeply nested immutable POJOs. 

An auto-generated, highly composable API for performing deeply nested updates on immutable POJOs. 

A practical Java lens library for performing deeply nested updates on immutable POJOs.

It creates declarative APIs for updating your code like this for free!   


## Quick Start 

The Lens API is auto-generated for anything you annotate with `@Lensed`. 

```java
@With
@Value
@Lensed   // ‚Üê All it takes!
class PurchaseOrder {
    String number; 
    Approval approval; 
}
@With
@Value
class Approval {
    ApprovalStatus status;
    Array<Comment> comments; 
    Confirmation customer;
}
@With
@Value
class Confirmation {
    UserAlias alias; 
    LocalDateTime updatedOn; 
}
```

>v0.0.1-alpha Note: Deoplice is currently symbiotic with `Lombok`. It depends on TODO. 

And you get a lovely declarative, composable update API for the annotated class and all of its children. You can now make complex, deeply nested updates to your data using an API custom generated for your blah   

```java
updatedOrder = setConfirmationUpdateOn(LocalDateTime.now())
    .andThen(setApprovalStatus("COMPLETED"))
    .andThen(updateApprovalComments(comments -> comments.append(someFinalComment))
    .apply(order)
```


 

It picks up where Lombok's `with` and `Builder` leaves off. 

### What's it look like? 

Easiest way to understand is with a quick example. 

```java
@Value
class PurchaseOrder {
    String number; 
    Approval approval; 
}
@Value
class Approval {
    ApprovalStatus status;
    Array<Comment> comments; 
    Confirmation customer;
}
@Value
class Confirmation {
    UserAlias alias; 
    LocalDateTime updatedOn; 
}
```

This is cool. Our domain is nicely typed. It's immutable, which removes whole classes of problems for free. But it has a major drawback: updating it is awkward as hell.

Let's say we want to mark one of these `PurchaseOrders` as completed, stamp the date when it was approved, and lastly any comments which were left by the approver. 

Using vanilla Withers via Lombok's `@With`

```java
updatedOrder = order.withApproval(
    order.getApproval()
        .withConfirmation(order.getApproval()
            .getConfirmation().withUpdatedOn(LocalDateTime.now()))
        .withStatus("COMPLETED")
        .withComments(order.getApproval()
            .getComments().append(someFinalComment)));
```

It's awful to read and awful to write. The _what_ we're doing is completely lost in the boilerplate. Deoplice generates a smart DSL for making modifications to immutable data structures first-class and declarative! 


```java 
updatedOrder = setConfirmationUpdateOn(LocalDateTime.now())
    .andThen(setApprovalStatus("COMPLETED"))
    .andThen(updateApprovalComments(comments -> comments.append(someFinalComment))
    .apply(order); 
```

Whoa! So much nicer! 

What's best, is that the setters generated by Deoplice are just plain ol' Java `Function`s. Meaning, you can use them anywhere and mix/match them with all your existing code.

Want to set all of your `PurchaseOrders` in a list to `COMPLETE`? Deoplice's got you: 

```java
completedOrders = pendingOrders.stream().map(setApprovalStatus("Completed")).toList(); 
```

## Lower level lens API

Behind the scenes, Deoplice is built on top of an idea called Lenses. What exactly is a Lens? It doesn't matter! It's some gobbledygook from functional programming. They're basically getters and setters that compose really well. All you have to know is that this has two



```set```

```update```


```java
updatedOrder=set($approval,$status,"COMPLETED")
        .andThen(set($approval,$confirmation,$updatedOn,LocalDateTime.now()))
        .andThen(update($approval,$comments,xs->xs.append(someFinalComment)))
        .apply(order)
```

And just like the DSL itself, these are just plain functions. So they play well with all existing java interfaces. 

```java 
completedOrders = pendingOrders.stream().map(set($approval, $status, "COMPLETED")).toList(); 
```


