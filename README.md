<p align="center">
    <img src="https://github.com/chriskiehl/Deoplice/raw/master/images/deoplice-logo.JPG"/>
</p>

>to a great depth

## Overview

Deoplice is java library that automatically generates a fancy API for transforming your immutable POJOs. It's **symbiotic** with [Lombok](https://projectlombok.org/)<sup>[0]</sup> and picks up where `@With` and `@Builder` leave off. It gives you a high level, auto-generated modification API that cuts through the boilerplate and let's you express changes exctly as intended.

## Table of Contents:

* About
* How does it work
* Lower level API
* Understanding code generation
* Customizing the generated API


>Note! Deoplice is currently in alpha and may have some bugs lurking around. Annotation processing is unexpectedly tricky and under-documented...

## How does it work?

Like Lombok, Deoplice works off annotations. To generate an API for your classes, all you've got to do is add the `@Updatable` annotation to any class that's already annotated with Lombok's `@With`.

```java
import deoplice.annotation.Updatable;

@With
@Value
@Updatable   // ‚Üê New Annotation! All it takes!  :) 
class PurchaseOrder {
    String number; 
    Approval approval; 
}
@With
@Value
class Approval {
    ApprovalStatus status;
    Array<Comment> comments; 
    Confirmation customer;
}
@With
@Value
class Confirmation {
    UserAlias alias; 
    LocalDateTime updatedOn; 
}
```

And that's it! At build time, Deoplice will generate a tailor-made API that lets you make declarative modifications with zero boilerplate. It looks like this:

```java
import static deoplice.generated.example.PurchaseOrderAPI.*;

updatedOrder = setConfirmationUpdatedOn(LocalDateTime.now())
    .andThen(setApprovalStatus("COMPLETED"))
    .andThen(updateApprovalComments(comments -> comments.append(someFinalComment))
    .apply(order)

updatedOrder = setApprovalCustomerUpdatedOn(LocalDateTime.now())
        .andThen(setApprovalStatus(COMPLETED))
        .andThen(setApprovalComments(Array.empty()))
        .apply()
```

So much nicer than vanilla Withers!

## Deoplice interops with all your existing code

The API generated by Deoplice consists of just plain ol' Java `Function`s. Meaning, you can use them anywhere and freely mix/match them with all your existing code.

For instance, got a collection of `PurchaseOrder`s and need to modify those `Confirmation` dates that are three levels deep? Deoplice's got you:

```java
completedOrders = pendingOrders.stream().map(setApprovalCustomerUpdatedOn(LocalDateTime.now())).toList(); 
```

How much is that saving us? Well here's what the same update would look like using the API provided by the with vanilla `@With`:

```java
completedOrders = pendingOrders.stream().map(order -> 
        order.withApproval(order.getApproval().withConfirmation(
                order.getApproval().getConfirmation().withUpdatedOn(LocalDateTime.now())
        )) 
    ).toList(); 
```

Gross! What we're trying to actually do is completely drowned in the boilerplate it takes to do it.

## Two primary APIs

Deoplice is build around two simple APIs: **setters** and **updaters**. Every field in your class with have two methods generated to modify it `set{Field}` and `update{field}`. 

**Setters** are for when you need to _replace_ a value. e.g. 

```java
setMyThingLastUpdatedOn(LocalDateTime.now()); 
```

**Updaters** are for when you need to compute a value based on what's currently there. e.g. 

```java
updateMyThingVersion(version -> version += 1); 
```

## A rich set of collection delegations

Deoplice has first class support for the standard collection types in `java.util.collection` as well as the author's preferred collection library `io.vavr.collection`! 

This means that you get an immutable API with Java's mutable collections for free! Usually, trying to treat java's collections as immutable leads to code that is punishingly verbose. 

```
@With 
@Value 
class MyStuff {
    List<String> things; 
}
```

Adding an item generally involves pulling the list out of the pojo, making a copy, doing the transform, and then `with`ing it back into place. Gross!  

```
List<String> original = mystuff.getThings()
List<String> updated = Stream.concat(original, Stream.of("newItem").collect(Collectors.toList());
return mystuff.withThings(updated); 
```

Deoplce does all of this for you behind the scenes! You get a functionally immutable API with which to interact with the standard java data structures!  

It turns all of the hullabalo above into this one-liner: 

```
addThings("newItem").apply(mystuff); 
```

Pretty sweet! 

**It also works for Vavr's collection types!** 

If you know then you know: vavr is the best. 

```
class MyStuff {
    Array<String> things; 
}
```

```
appendThings("myNewItem").apply(mystuff); 
```

Deoplice supports all the popular actions like appending, prepending, dropping, filtering, etc.. 


## How to find and use the generated files

Deoplice's generated files are all namespaced with your package name prefixed with `deoplice.generated` e.g.

```
deoplice.generated.{package.of.your.annotated.model}
``` 

So, if your class looks something like this

```java
package foo.bar;

class Foo {
    String bar; 
    // ... 
}
```

You'll find the generated files in your default build directory. e.g.

```
builddir/ 
   |-- deoplice.generated.foo.bar.
       |-- FooAPI.java
       |-- FooLens.java 
```

You'd import them like anything else:

```java
import deoplice.generated.foo.bar.FooAPI;
```

**But the easier way is too...**

Ignore all the specifics of build systems, annotation dirs, and what goes where and just let your IDE figure out (it's very good at this!)

![Using auto-complete](https://github.com/chriskiehl/Deoplice/raw/master/images/autocomplete.gif)



## Code Generation



## Customizing the API




## Lower level lens API

Is the high level API not doing what you need? There's a lower level API you can use!

Behind the scenes, Deoplice generates a set of Lenses[0] for all your class' fields. What exactly is a Lens? It's some gobbledygook from functional programming. They're basically getters and setters that compose together really well. They're what gives deoplice the ability to cleanly perform updates on deeply nested objects.

Given a simple class that we've annotated with `@Updatable`

```java
@With
@Value
@Updatable
class Car {
    String make;
    Driver driver;
}
@With
@Value
@Updatable
class Driver {
    String name;
    Interger age;
}
```

For each class and field, it'll generate a set of lenses. They look like this:

```java
public static Lens<Car, String> $make = makeLens(Car::getMake, Car::withMake);
public static Lens<Car, String> $model = makeLens(Car::getModel, Car::withModel);

        ...

public static Lens<Car, String> $model = makeLens(Driver::getName, Driver::withName);
public static Lens<Car, String> $model = makeLens(Driver::getAge, Driver::withAge);
```

>By default, lenses are all prefixed with `$` so they can be statically imported without collision. See [this section] for how to customize or remove this.

You can import these and use them directly to perform updates.

```
```



```set```

```update```

```java
updatedOrder=set($approval,$status,"COMPLETED")
        .andThen(set($approval,$confirmation,$updatedOn,LocalDateTime.now()))
        .andThen(update($approval,$comments,xs->xs.append(someFinalComment)))
        .apply(order)
```

And just like the DSL itself, these are just plain functions. So they play well with all existing java interfaces.

```java 
completedOrders = pendingOrders.stream().map(set($approval, $status, "COMPLETED")).toList(); 
```


### Current quirks, limitations, and roadmap

**Type Params and Wildcards**

```java
@Value 
public class MyFoo<A> {/*...*/} 
```

Deoplice doesn't currently have the smartest support for classes with generics. The alpha release uses wildcards in the generated API for simplicity. This means that some calls will need casting in order to help the compiler understand the target type.

This is on the roadmap to fix because it's annoying. 


### Footnotes

* [0] Although it's open for new possible bespoke strategies
* [0] You may scoff at my hyper-simplified / dumbed down take on Lenses. That's OK. Deoplice isn't trying to be a lens library. It only borrows what's useful for its goals -- which is simply making the "common case" update paths less clunky to do in java.   