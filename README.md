Deoplice 

"to a great depth"

An auto-generated, highly composable API for performing deeply nested updates on immutable POJOs. 

A practical Java lens library for performing deeply nested updates on immutable POJOs.

It creates declarative APIs for updating your code like this for free!   

```
updatedOrder = setConfirmationUpdateOn(LocalDateTime.now())
    .andThen(setApprovalStatus("COMPLETED"))
    .andThen(updateApprovalComments(comments -> comments.append(someFinalComment))
    .apply(order)
```


What's a Lens? It doesn't matter! It's some gobbledygook from functional programming. They're basically getters and setters that compose really well. The only problem with them is that then can be super awkward to use in Java and require a lot of boilerplate. 

It picks up where Lombok's `with` leaves off. 

### What's it look like? 

Easiest way to understand is with a quick example. 

```
@Value
class PurchaseOrder {
    String number; 
    Approval approval; 
}
@Value
class Approval {
    ApprovalStatus status;
    Array<Comment> comments; 
    Confirmation customer;
}
@Value
class Confirmation {
    UserAlias alias; 
    LocalDateTime updatedOn; 
}
```

This is cool. Our domain is nicely typed. It's immutable, which removes whole classes of problems for free. But it has a major drawback: updating it is awkward as hell.

Let's say we want to mark one of these `PurchaseOrders` as completed, stamp the date when it was approved, and lastly any comments which were left by the approver. 

Using vanilla Withers via Lombok's `@With`

```java
updatedOrder = order.withApproval(
    order.getApproval()
        .withConfirmation(order.getApproval()
            .getConfirmation().withUpdatedOn(LocalDateTime.now()))
        .withStatus("COMPLETED")
        .withComments(order.getApproval()
            .getComments().append(someFinalComment)));
```

It's awful to read and awful to write. The _what_ we're doing is completely lost in the boilerplate. Deoplice generates a smart DSL for making modifications to immutable data structures first-class and declarative! 


```java 
updatedOrder = setConfirmationUpdateOn(LocalDateTime.now())
    .andThen(setApprovalStatus("COMPLETED"))
    .andThen(updateApprovalComments(comments -> comments.append(someFinalComment))
    .apply(order); 
```

Whoa! So much nicer! 

What's best, is that the setters generated by Deoplice are just plain ol' Java `Function`s. Meaning, you can use them anywhere and mix/match them with all your existing code.

Want to set all of your `PurchaseOrders` in a list to `COMPLETE`? Deoplice's got you: 

```java
completedOrders = pendingOrders.stream().map(setApprovalStatus("Completed")).toList(); 
```

## Lower level lens API

If you don't want to use the higher level DSL, Deoplice has a lovely API for creating complex modifications via its generated lenses -- this is what the DSL uses behind the scenes!

```java


updatedOrder=set($approval,$status,"COMPLETED")
        .andThen(set($approval,$confirmation,$updatedOn,LocalDateTime.now()))
        .andThen(update($approval,$comments,xs->xs.append(someFinalComment)))
        .apply(order)
```

And just like the DSL itself, these are just plain functions. So they play well with all existing java interfaces. 

```java 
completedOrders = pendingOrders.stream().map(set($approval, $status, "COMPLETED")).toList(); 
```



